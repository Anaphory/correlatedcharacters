<beast version='2.0' namespace='correlatedcharacters.polycharacter'>

	<mergewith point='aux-partitions-panels'>
		<alignmentProvider id="Add Correlated Morphological Data"
			spec='correlatedcharacters.beauti.CompoundAlignmentProvider'
			template='@CorrelatedTrait' />

		<subtemplate id='CorrelatedTrait'
			class='correlatedcharacters.polycharacter.CompoundAlignment' mainid='$(n)'>
			<![CDATA[
				<!-- tree and its properties -->
				<taxonset id='TaxonSet.$(n)' spec='beast.evolution.alignment.TaxonSet'
					alignment='@compound.$(n)' />
				<tree spec='beast.evolution.tree.Tree' id='Tree.t:$(n)'
					taxonset='@TaxonSet.$(n)' />

				<!-- Compound and inner alignments -->
				<correlatedAlignment spec="correlatedcharacters.polycharacter.CompoundAlignment" id='compound.$(n)'>					
					<alignment spec="beast.evolution.alignment.Alignment" id='$(n)' />
				</correlatedAlignment>
				
				<!-- Substitution model parameters rates are generated by parameterclone. -->

				<parameter spec='parameterclone.selector.Selector' id='rates.$(n)' parameters='@rateValues.$(n)' groupings='@groupings.$(n)'/>
				<frequencies id='frequencies.$(n)' spec='beast.evolution.substitutionmodel.Frequencies' data='@compound.$(n)' />

				<!--plugin spec='beast.evolution.tree.RandomTree' id='RandomTree.t:$(n)' 
					estimate='false' trait='@datetrait.$(n)' initial='@Tree.t:$(n)' -->
				<init spec='beast.evolution.tree.RandomTree' id='RandomTree.t:$(n)'
					estimate='false' initial='@Tree.t:$(n)' taxa='@$(n)'>
					<populationModel id='ConstantPopulation0.t:$(n)'
						spec='ConstantPopulation'>
						<popSize id='randomPopSize.t:$(n)' spec='parameter.RealParameter'
							value='1' />
					</populationModel>
				</init>

				<distribution id="morphTreeLikelihood.$(n)" spec='TreeLikelihood' data='@compound.$(n)'
					tree='@Tree.t:$(n)'>
					<siteModel spec='SiteModel' id="morphSiteModel.s:$(n)"
						gammaCategoryCount='1'>
						<proportionInvariant spec='parameter.RealParameter'
							id='proportionInvariant.s:$(n)' value='0.0' lower='0' upper='1'
							estimate='false' />
						<mutationRate spec='parameter.RealParameter' id='mutationRate.s:$(n)'
							value='1.0' estimate='false' />
						<shape spec='parameter.RealParameter' id='gammaShape.s:$(n)'
							value='1.0' estimate='false' />
						<!-- Correlated subst model -->
						<substModel spec="correlatedcharacters.polycharacter.CorrelatedSubstitutionModel"
							id="CorrelatedSubstitution_manual.s:$(n)"
							rates="@rates.$(n)"
							frequencies='@frequencies.$(n)'
							alignment='@compound.$(n)'/>
					</siteModel>
					<branchRateModel id="StrictClockModel.c:$(n)"
						spec="beast.evolution.branchratemodel.StrictClockModel">
						<parameter id="clockRate.c:$(n)" name="clock.rate"
							value="1.0" />
					</branchRateModel>
				</distribution>

				<!-- default tree prior -->
				<plugin spec='YuleModel' id="YuleModel.t:$(n)" tree='@Tree.t:$(n)'>
					<parameter name='birthDiffRate' id="birthRate.t:$(n)"
						value='1.0' estimate='true' />
				</plugin>

				<distribution id='ClockPrior.c:$(n)' x="@clockRate.c:$(n)"
					spec='beast.math.distributions.Prior'>
					<distr spec='beast.math.distributions.Gamma' alpha="0.001"
						beta="1000." offset="0.0" />
				</distribution>
				<prior spec='beast.math.distributions.Prior' id='YuleBirthRatePrior.t:$(n)'
					x='@birthRate.t:$(n)'>
					<distr spec="beast.math.distributions.Uniform" lower='0'
						upper='Infinity' />
				</prior>
				<prior id='GammaShapePrior.s:$(n)' x='@gammaShape.s:$(n)'>
					<distr spec="beast.math.distributions.Exponential" mean='1' />
				</prior>
				<prior id='PropInvariantPrior.t:$(n)' x='@proportionInvariant.s:$(n)'>
					<distr spec="beast.math.distributions.Uniform" lower='0'
						upper='1' />
				</prior>

				<operator id='YuleBirthRateScaler.t:$(n)' spec='ScaleOperator'
					scaleFactor="0.75" weight="3" parameter="@birthRate.t:$(n)" />

				<operator id='proportionInvariantScaler.s:$(n)' spec='ScaleOperator'
					scaleFactor="0.5" weight="0.1" parameter="@proportionInvariant.s:$(n)" />
				<operator id='mutationRateScaler.s:$(n)' spec='ScaleOperator'
					scaleFactor="0.5" weight="0.1" parameter="@mutationRate.s:$(n)" />
				<operator id='gammaShapeScaler.s:$(n)' spec='ScaleOperator'
					scaleFactor="0.5" weight="0.1" parameter="@gammaShape.s:$(n)" />

				<operator id='treeScaler.t:$(n)' spec='ScaleOperator'
					scaleFactor="0.5" weight="3" tree="@Tree.t:$(n)" />
				<operator id='treeRootScaler.t:$(n)' spec='ScaleOperator'
					scaleFactor="0.5" weight="3" tree="@Tree.t:$(n)" rootOnly='true' />
				<operator id='UniformOperator.t:$(n)' spec='Uniform'
					weight="30" tree="@Tree.t:$(n)" />
				<operator id='SubtreeSlide.t:$(n)' spec='SubtreeSlide'
					weight="15" gaussian="true" size="1.0" tree="@Tree.t:$(n)" />
				<operator id='narrow.t:$(n)' spec='Exchange' isNarrow='true'
					weight="15" tree="@Tree.t:$(n)" />
				<operator id='wide.t:$(n)' spec='Exchange' isNarrow='false'
					weight="3" tree="@Tree.t:$(n)" />
				<operator id='WilsonBalding.t:$(n)' spec='WilsonBalding'
					weight="3" tree="@Tree.t:$(n)" />
    			<operator id="UpDown.t:$(n)" scaleFactor="1.0" spec="UpDownOperator" weight="0.5"
     				up="@Tree.t:$(n)" down="birthRate.t:$(n)" />
    			<operator groupings="@groupings.$(n)" id="Merger.t:$(n)" parameters="@rateValues.$(n)" sizes="@sizes.$(n)" spec="parameterclone.splitandmerge.MergeOperator" weight="10.0" />
    			<operator groupings="@groupings.$(n)" id="Splitter.t:$(n)" parameters="@rateValues.$(n)" sizes="@sizes.$(n)" spec="parameterclone.splitandmerge.SplitOperator" weight="10.0" />
				<operator id="Exchange.t:$(n)" spec="DeltaExchangeOperator"
					parameter="@rateValues.$(n)" delta="1.0" weightvector="@sizes.$(n)" weight="10.0" />
				]]>

			<connect srcID='morphTreeLikelihood.$(n)' targetID='likelihood'
				inputName='distribution' if="isInitializing" />
			<connect srcID='YuleModel.t:$(n)' targetID='prior' inputName='distribution'
				if="isInitializing" />

			<connect srcID='treelog.t:$(n)' targetID='mcmc' inputName='logger'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true' />
			<connect srcID='RandomTree.t:$(n)' targetID='mcmc' inputName='init'
				if='inposterior(Tree.t:$(n))' />

			<connect srcID='ClockPrior.c:$(n)' targetID='prior'
				inputName='distribution'
				if='inposterior(morphTreeLikelihood.$(n)) and inlikelihood(clockRate.c:$(n)) and clockRate.c:$(n)/estimate=true' />
			<connect srcID='MutationRatePrior.s:$(n)' targetID='prior'
				inputName='distribution'
				if='nooperator(FixMeanMutationRatesOperator) and inlikelihood(mutationRate.s:$(n)) and mutationRate.s:$(n)/estimate=true' />
			<connect srcID='YuleBirthRatePrior.t:$(n)' targetID='prior'
				inputName='distribution'
				if='inposterior(YuleModel.t:$(n)) and inposterior(Tree.t:$(n)) and birthRate.t:$(n)/estimate=true'>Prior on Yule birth rate for partition s:$(n)</connect>
			<connect srcID='GammaShapePrior.s:$(n)' targetID='prior'
				inputName='distribution'
				if='inlikelihood(gammaShape.s:$(n)) and gammaShape.s:$(n)/estimate=true'>Prior on gamma shape for partition s:$(n)</connect>
			<connect srcID='PropInvariantPrior.s:$(n)' targetID='prior'
				inputName='distribution'
				if='inlikelihood(proportionInvariant.s:$(n)) and proportionInvariant.s:$(n)/estimate=true'>Prior on proportion invariant for partition s:$(n)</connect>

			<connect srcID='birthRate.t:$(n)' targetID='state' inputName='stateNode'
				if='inposterior(YuleModel.t:$(n)) and inposterior(Tree.t:$(n)) and birthRate.t:$(n)/estimate=true' />
			<connect srcID='clockRate.c:$(n)' targetID='state' inputName='stateNode'
				if='inposterior(morphTreeLikelihood.$(n)) and inlikelihood(clockRate.c:$(n)) and clockRate.c:$(n)/estimate=true' />
			<connect srcID='proportionInvariant.s:$(n)' targetID='state'
				inputName='stateNode'
				if='inlikelihood(proportionInvariant.s:$(n)) and proportionInvariant.s:$(n)/estimate=true' />
			<connect srcID='mutationRate.s:$(n)' targetID='state'
				inputName='stateNode'
				if='inlikelihood(mutationRate.s:$(n)) and mutationRate.s:$(n)/estimate=true' />
			<connect srcID='gammaShape.s:$(n)' targetID='state'
				inputName='stateNode'
				if='inlikelihood(gammaShape.s:$(n)) and gammaShape.s:$(n)/estimate=true' />

			<connect srcID='rateValues.$(n)' targetID='state' inputName='stateNode'
				if='inposterior(Tree.t:$(n))' />
			<connect srcID='groupings.$(n)' targetID='state' inputName='stateNode'
				if='inposterior(Tree.t:$(n))' />
			<connect srcID='sizes.$(n)' targetID='state' inputName='stateNode'
				if='inposterior(Tree.t:$(n))' />

			<connect srcID='mutationRateScaler.c:$(n)' targetID='mcmc'
				inputName='operator'
				if='inposterior(morphTreeLikelihood.$(n)) and inlikelihood(clockRate.c:$(n)) and clockRate.c:$(n)/estimate=true'>Scales migration rate of morphological characters on partition
				$(n)
			</connect>
			<connect srcID='YuleBirthRateScaler.t:$(n)' targetID='mcmc'
				inputName='operator'
				if='inposterior(birthRate.t:$(n)) and birthRate.t:$(n)/estimate=true'>Scales birth rate of Yule prior for partition t:$(n)</connect>
			<connect srcID='proportionInvariantScaler.s:$(n)' targetID='mcmc'
				inputName='operator'
				if='inlikelihood(proportionInvariant.s:$(n)) and proportionInvariant.s:$(n)/estimate=true'>Scales proportion of invariant sites parameter of partition $(n)
			</connect>
			<connect srcID='mutationRateScaler.s:$(n)' targetID='mcmc'
				inputName='operator'
				if='nooperator(FixMeanMutationRatesOperator) and inlikelihood(mutationRate.s:$(n)) and mutationRate.s:$(n)/estimate=true'>Scales mutation rate of partition s:$(n)</connect>
			<connect srcID='gammaShapeScaler.s:$(n)' targetID='mcmc'
				inputName='operator'
				if='inlikelihood(gammaShape.s:$(n)) and gammaShape.s:$(n)/estimate=true'>Scales gamma shape parameter of partition s:$(n)</connect>

			<connect srcID='treeScaler.t:$(n)' targetID='mcmc' inputName='operator'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Scales all internal nodes for tree t:$(n)</connect>
			<connect srcID='treeRootScaler.t:$(n)' targetID='mcmc'
				inputName='operator' if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Scales root node for tree t:$(n)</connect>
			<connect srcID='UniformOperator.t:$(n)' targetID='mcmc'
				inputName='operator' if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Draws new internal node heights uniformally
				for tree t:$(n)
			</connect>
			<connect srcID='SubtreeSlide.t:$(n)' targetID='mcmc'
				inputName='operator' if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Performs subtree slide rearrangement of tree
				t:$(n)
			</connect>
			<connect srcID='narrow.t:$(n)' targetID='mcmc' inputName='operator'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Narrow exchange performs local rearrangement of tree t:$(n)
			</connect>
			<connect srcID='wide.t:$(n)' targetID='mcmc' inputName='operator'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Wide exchange performs global rearrangement of tree t:$(n)
			</connect>
			<connect srcID='WilsonBalding.t:$(n)' targetID='mcmc'
				inputName='operator' if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Performs Wilson-Balding global rearrangement
				of tree t:$(n)
			</connect>
			<connect srcID="Merger.t:$(n)" targetID='mcmc' inputName='operator'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Merges evolutionary rates in t:$(n)
			</connect>
			<connect srcID="Splitter.t:$(n)" targetID='mcmc' inputName='operator'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Ungroups evolutionary rates in t:$(n)
			</connect>
			<connect srcID="Exchange.t:$(n)" targetID='mcmc' inputName='operator'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Changes the rates in t:$(n)
			</connect>

			<connect srcID='strictClockUpDownOperator.c:$(n)' targetID='mcmc'
				inputName='operator'
				if='nooperator(FixMeanRatesOperator) and inlikelihood(clockRate.c:$(n)) and inlikelihood(Tree.t:$(n)) and Tree.t:$(n)/estimate=true and clockRate.c:$(n)/estimate=true'>Scale up substitution rate c:$(n) and scale down tree t:($n)
			</connect>

			<connect srcID='morphTreeLikelihood.$(n)' targetID='tracelog'
				inputName='log' if='inlikelihood(morphTreeLikelihood.$(n))' />
			<connect srcID='TreeHeight.t:$(n)' targetID='tracelog'
				inputName='log' if='inposterior(Tree.t:$(n))' />
			<connect srcID='proportionInvariant.s:$(n)' targetID='tracelog'
				inputName='log'
				if='inposterior(proportionInvariant.s:$(n)) and proportionInvariant.s:$(n)/estimate=true' />
			<connect srcID='mutationRate.s:$(n)' targetID='tracelog'
				inputName='log'
				if='inlikelihood(mutationRate.s:$(n)) and mutationRate.s:$(n)/estimate=true' />
			<connect srcID='gammaShape.s:$(n)' targetID='tracelog'
				inputName='log'
				if='inlikelihood(gammaShape.s:$(n)) and gammaShape.s:$(n)/estimate=true' />
			<connect srcID='clockRate.c:$(n)' targetID='tracelog'
				inputName='log'
				if='inlikelihood(clockRate.c:$(n)) and clockRate.c:$(n)/estimate=true' />
			<connect srcID='YuleModel.t:$(n)' targetID='tracelog'
				inputName='log'
				if='inposterior(YuleModel.t:$(n)) and inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true' />
			<connect srcID='birthRate.t:$(n)' targetID='tracelog'
				inputName='log'
				if='inposterior(YuleModel.t:$(n)) and birthRate.t:$(n)/estimate=true' />

			<connect srcID='treeScaler.t:$(n)' targetID='mcmc' inputName='operator'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Scales all internal nodes for tree t:$(n)</connect>
			<connect srcID='treeRootScaler.t:$(n)' targetID='mcmc'
				inputName='operator' if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Scales root node for tree t:$(n)</connect>
			<connect srcID='UniformOperator.t:$(n)' targetID='mcmc'
				inputName='operator' if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Draws new internal node heights uniformally
				for tree t:$(n)
			</connect>
			<connect srcID='SubtreeSlide.t:$(n)' targetID='mcmc'
				inputName='operator' if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Performs subtree slide rearrangement of tree
				t:$(n)
			</connect>
			<connect srcID='narrow.t:$(n)' targetID='mcmc' inputName='operator'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Narrow exchange performs local rearrangement of tree t:$(n)
			</connect>
			<connect srcID='wide.t:$(n)' targetID='mcmc' inputName='operator'
				if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Wide exchange performs global rearrangement of tree t:$(n)
			</connect>
			<connect srcID='WilsonBalding.t:$(n)' targetID='mcmc'
				inputName='operator' if='inposterior(Tree.t:$(n)) and Tree.t:$(n)/estimate=true'>Performs Wilson-Balding global rearrangement
				of tree t:$(n)
			</connect>
			<connect srcID='strictClockUpDownOperator.c:$(n)' targetID='mcmc'
				inputName='operator'
				if='nooperator(FixMeanRatesOperator) and inlikelihood(clockRate.c:$(n)) and inlikelihood(Tree.t:$(n)) and Tree.t:$(n)/estimate=true and clockRate.c:$(n)/estimate=true'>Scale up substitution rate c:$(n) and scale down tree t:($n)
			</connect>

		</subtemplate>

	</mergewith>

	<mergewith point='substModelTemplates'>

		<!-- CorrelatedSubstitution substitution model -->
		<subtemplate id='CorrelatedSubstitution'
			class='correlatedcharacters.polycharacter.CorrelatedSubstitutionModel'
			mainid='CorrelatedSubstitution.s:$(n)'>
<![CDATA[
    <!--<plugin spec='correlatedcharacters.polycharacter.CorrelatedSubstitutionModel' id='CorrelatedSubstitution.s:$(n)'/>-->
]]>
		</subtemplate>
	</mergewith>

</beast>

