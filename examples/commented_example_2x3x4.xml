<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<beast version='2.0'
	namespace="beast.core:beast.core.util:beast.evolution.alignment">
	<map name="prior">beast.math.distributions.Prior</map>

	<!-- This example file shows how to set up a beast analysis of correlated 
		character evolution under a reversible Markov chain assumption. It shows 
		how to set up more than two non-binary characters co-evolving. -->

	<!-- The data is given by an alignment. In order to avoid manually messing 
		with indices, it is recommended to use the CompoundAlignment structure – 
		the package's tests enforce that the indexing structure of CompoundAligment 
		and all other components of the correlated evolution model are compatible. -->
	<data id="characters" spec="correlated.polycharacter.CompoundAlignment">
		<!-- CompoundAlignment takes as its main input another (short) alignment, 
			the columns of which it then aggregates. For a sub-alignment with non-equal 
			data types, such as in the 2×3×4 example we construct, this is more complex. -->
		<alignment id="characters1" dataType="user defined" spec="Alignment">
			<userDataType spec="beast.evolution.datatype.StandardData"
				nrOfStates="6">
				<charstatelabels id="Column1"
					spec="beast.evolution.datatype.Binary" />
				<charstatelabels id="Column2"
					spec="beast.evolution.datatype.UserDataType" characterName="A Ternary Character"
					codeMap="0=0, 1=1, 2=2, ?=0 1 2" states="3" value="0, 1, 2" />
				<charstatelabels id="Column3"
					spec="beast.evolution.datatype.UserDataType" characterName="A Quartary Character"
					codeMap="0=0, 1=1, 2=2, 3=3, ?=0 1" states="4" value="0, 1, 2, 3" />
			</userDataType>
			<sequence id="ch_1a" taxon="t1" value="003" />
			<sequence id="ch_2a" taxon="t2" value="110" />
			<sequence id="ch_3a" taxon="t3" value="121" />
			<sequence id="ch_4a" taxon="t4" value="122" />
		</alignment>
		<!-- Because of how data types and ambiguities work internally, the CompoundAlignment 
			cannot guess the shape of the data type in this example. We therefore specify 
			it as a CompoundDataType. -->
		<userDataType spec="correlated.polycharacter.CompoundDataType">
			<components idref="Column1" />
			<components idref="Column2" />
			<components idref="Column3" />
		</userDataType>
	</data>

	<run chainLength="200" id="mcmc" spec="MCMC" preBurnin="0">
		<state id="state" storeEvery="100">
			<tree id="tree" name="stateNode" />

			<!-- We have 2×3×4=24 states. Each component of each state can switch, 
				along one of (2-1)+(3-1)+(4-1)=6 edges. We therefore have at most 6*24=144 
				different rates. -->
			<parameter id="rates" name="stateNode">
				1 1 1 1 1 1 1 1 1 1 1 1
				1 1 1 1 1
				1 1 1 1 1 1 1
				1 1 1 1 1 1 1 1 1 1 1 1
				1 1 1 1 1 1 1 1 1 1 1 1
				1 1 1 1 1
				1 1 1 1 1 1 1
				1 1 1 1 1 1 1 1 1 1 1 1
				1 1 1 1 1 1 1 1 1 1 1 1
				1 1 1 1 1
				1 1 1 1 1 1 1
				1 1 1 1 1 1 1 1 1 1 1 1
				1 1 1 1 1 1 1 1 1 1 1 1
				1 1 1 1 1
				1 1 1 1 1 1 1
				1 1 1 1 1 1 1 1 1 1 1 1
			</parameter>
		</state>

		<init id="treeinit" initial="@tree" spec="beast.util.TreeParser"
			IsLabelledNewick="true" newick="(t3:2,(t1:1,t2:1):1);" taxa="@characters">
		</init>

		<!-- This operator does nothing, because it scales "1"s by "1". -->
		<operator id="treeModel000(narrow)" spec="beast.evolution.operators.ScaleOperator"
			parameter="@rates" weight="1" />

		<distribution id="posterior" spec="CompoundDistribution">
			<distribution id="prior" spec="CompoundDistribution">
				<prior id="ratesPrior" name="distribution" x="@rates">
					<distr id="lognormalrate" spec="beast.math.distributions.Exponential">
						<parameter estimate="false" id="r0" name="mean" value="1" />
					</distr>
				</prior>
			</distribution>
			<distribution id="likelihood" spec="CompoundDistribution">
				<distribution id="treelk"
					spec="beast.evolution.likelihood.TreeLikelihood" tree="@tree" data="@characters">
					<siteModel id="sitemodel" spec="beast.evolution.sitemodel.SiteModel">
						<!-- The correlated substitution model also needs input about the shape 
							of the alignment. -->
						<substModel id="subst"
							spec="correlated.polycharacter.CorrelatedSubstitutionModel"
							rates="@rates" shape="2 3 4">
							<frequencies name="frequencies" id="frequencies"
								spec="beast.evolution.substitutionmodel.Frequencies" estimate="false">
								<parameter name="frequencies">
									0.08 0.04 0.04 0.04 0.04 0.04 0.04
									0.04 0.04 0.04 0.04 0.04 0.04
									0.04 0.04 0.04 0.04 0.04 0.04 0.04
									0.04 0.04 0.04 0.04
								</parameter>
							</frequencies>
						</substModel>
					</siteModel>
				</distribution>
			</distribution>
		</distribution>

		<logger id="screenlog" logEvery="1">
			<plate var="n" range="posterior,prior,ratesPrior,likelihood,treelk">
				<log idref="$(n)" />
			</plate>
			<log idref="rates" />
		</logger>

		<logger id="treelog" fileName="test.trees">
			<log idref="tree" />
		</logger>
	</run>
</beast>